//! Swift code generator for BAML
//!
//! This crate generates Swift code from BAML intermediate representation (IR).
//! The generated code depends on the SWAML runtime package.
//!
//! # Usage
//!
//! ```rust,ignore
//! use baml_generator_swift::{SwiftGenerator, GeneratorConfig, BamlIR};
//!
//! let ir = BamlIR::default();
//! // ... populate IR with classes, enums, functions ...
//!
//! let generator = SwiftGenerator::with_defaults();
//! let files = generator.generate(&ir)?;
//! ```

pub mod generated_types;
pub mod ir_to_swift;
pub mod package;
pub mod r#type;
pub mod utils;

// Keep the old modules for backwards compatibility
mod functions;
mod swift_types;

// BAML parser integration (requires baml-ir feature)
#[cfg(feature = "baml-ir")]
pub mod baml_parser;

#[cfg(feature = "baml-ir")]
pub use baml_parser::{parse_baml_dir, parse_baml_string};

use anyhow::Result;
use askama::Template;

pub use generated_types::*;
pub use ir_to_swift::classes::{ClassDef, FieldDef};
pub use ir_to_swift::enums::{EnumDef, EnumValueDef};
pub use ir_to_swift::functions::{FunctionDef, ParamDef};
pub use ir_to_swift::type_aliases::TypeAliasDef;
pub use ir_to_swift::unions::UnionDef;
pub use ir_to_swift::FieldType;
pub use package::{FileCollector, GenerationContext, GeneratorConfig};
pub use r#type::{SerializeType, TypeSwift};

// Re-export old types for backwards compatibility
pub use functions::*;
pub use swift_types::*;

/// Content prefix for all generated files
pub const CONTENT_PREFIX: &str = "// Generated by BAML - do not edit\n// swift-format-ignore-file\n";

/// Simplified BAML IR for the generator
///
/// This IR abstracts away the details of the actual BAML IntermediateRepr,
/// making the generator easier to test and use independently.
#[derive(Debug, Clone, Default)]
pub struct BamlIR {
    /// Enum definitions
    pub enums: Vec<EnumDef>,
    /// Class definitions
    pub classes: Vec<ClassDef>,
    /// Function definitions
    pub functions: Vec<FunctionDef>,
    /// Type alias definitions
    pub type_aliases: Vec<TypeAliasDef>,
    /// Client configurations
    pub clients: Vec<ClientConfigSwift>,
}

/// Main Swift code generator
///
/// This generator takes a BamlIR and produces Swift source files
/// that can be used with the SWAML runtime.
pub struct SwiftGenerator {
    config: GeneratorConfig,
}

impl SwiftGenerator {
    /// Create a new Swift generator with the given configuration
    pub fn new(config: GeneratorConfig) -> Self {
        Self { config }
    }

    /// Create a new Swift generator with default configuration
    pub fn with_defaults() -> Self {
        Self::new(GeneratorConfig::default())
    }

    /// Generate all Swift files from the BAML IR
    pub fn generate(&self, ir: &BamlIR) -> Result<FileCollector> {
        // Create generation context with known types
        let class_names: Vec<String> = ir.classes.iter().map(|c| c.name.clone()).collect();
        let enum_names: Vec<String> = ir.enums.iter().map(|e| e.name.clone()).collect();
        let type_alias_names: Vec<String> = ir.type_aliases.iter().map(|t| t.name.clone()).collect();

        let ctx = GenerationContext::with_types(
            self.config.clone(),
            class_names,
            enum_names,
            type_alias_names,
        );

        let mut collector = FileCollector::new();

        // Convert IR types to Swift types
        let enums = self.convert_enums(&ir.enums, &ctx);
        let classes = self.convert_classes(&ir.classes, &ctx);
        let type_aliases = self.convert_type_aliases(&ir.type_aliases, &ctx);
        let unions = self.collect_unions(ir, &ctx);
        let functions = self.convert_functions(&ir.functions, &ctx);

        // Generate Types.swift
        let types_content = self.generate_types(&enums, &classes, &type_aliases)?;
        collector.add_file(
            format!("{}/Types.swift", self.config.output_dir),
            types_content,
        );

        // Generate Unions.swift (if there are any unions)
        if !unions.is_empty() {
            let unions_content = self.generate_unions(&unions)?;
            collector.add_file(
                format!("{}/Unions.swift", self.config.output_dir),
                unions_content,
            );
        }

        // Generate BamlClient.swift
        let client_content = self.generate_client(&functions)?;
        collector.add_file(
            format!("{}/BamlClient.swift", self.config.output_dir),
            client_content,
        );

        // Generate Globals.swift
        let globals_content = self.generate_globals(&ir.clients)?;
        collector.add_file(
            format!("{}/Globals.swift", self.config.output_dir),
            globals_content,
        );

        // Generate streaming types if enabled
        if self.config.generate_streaming {
            let stream_classes = self.convert_stream_classes(&ir.classes, &ctx);
            if !stream_classes.is_empty() {
                let stream_content = self.generate_stream_types(&stream_classes)?;
                collector.add_file(
                    format!("{}/StreamTypes.swift", self.config.output_dir),
                    stream_content,
                );
            }
        }

        Ok(collector)
    }

    /// Convert enum definitions to Swift enum representations
    fn convert_enums(&self, enums: &[EnumDef], ctx: &GenerationContext) -> Vec<EnumSwift> {
        enums
            .iter()
            .map(|e| ir_to_swift::enums::enum_def_to_swift(e, ctx))
            .collect()
    }

    /// Convert class definitions to Swift struct representations
    fn convert_classes(&self, classes: &[ClassDef], ctx: &GenerationContext) -> Vec<ClassSwift> {
        classes
            .iter()
            .map(|c| ir_to_swift::classes::class_def_to_swift(c, ctx))
            .collect()
    }

    /// Convert class definitions to streaming (partial) Swift struct representations
    fn convert_stream_classes(
        &self,
        classes: &[ClassDef],
        ctx: &GenerationContext,
    ) -> Vec<ClassSwift> {
        classes
            .iter()
            .map(|c| ir_to_swift::classes::class_def_to_swift_stream(c, ctx))
            .collect()
    }

    /// Convert type alias definitions to Swift typealias representations
    fn convert_type_aliases(
        &self,
        aliases: &[TypeAliasDef],
        ctx: &GenerationContext,
    ) -> Vec<TypeAliasSwift> {
        aliases
            .iter()
            .map(|a| ir_to_swift::type_aliases::type_alias_def_to_swift(a, ctx))
            .collect()
    }

    /// Collect all union types that need to be generated
    fn collect_unions(&self, ir: &BamlIR, ctx: &GenerationContext) -> Vec<UnionSwift> {
        let mut union_defs: Vec<UnionDef> = Vec::new();

        // Collect unions from class fields
        for class in &ir.classes {
            for field in &class.fields {
                ir_to_swift::unions::collect_unions_from_field_type(
                    &field.field_type,
                    ctx,
                    &mut union_defs,
                );
            }
        }

        // Collect unions from function parameters and return types
        for func in &ir.functions {
            for param in &func.params {
                ir_to_swift::unions::collect_unions_from_field_type(
                    &param.param_type,
                    ctx,
                    &mut union_defs,
                );
            }
            ir_to_swift::unions::collect_unions_from_field_type(
                &func.return_type,
                ctx,
                &mut union_defs,
            );
        }

        // Convert collected unions to UnionSwift
        union_defs
            .iter()
            .map(|u| ir_to_swift::unions::union_def_to_swift(u, ctx))
            .collect()
    }

    /// Convert function definitions to Swift function representations
    fn convert_functions(
        &self,
        functions: &[FunctionDef],
        ctx: &GenerationContext,
    ) -> Vec<FunctionSwift> {
        functions
            .iter()
            .map(|f| ir_to_swift::functions::function_def_to_swift(f, ctx))
            .collect()
    }

    /// Generate Types.swift content
    fn generate_types(
        &self,
        enums: &[EnumSwift],
        classes: &[ClassSwift],
        type_aliases: &[TypeAliasSwift],
    ) -> Result<String> {
        let template = TypesTemplate {
            enums,
            classes,
            type_aliases,
        };
        Ok(template.render()?)
    }

    /// Generate Unions.swift content
    fn generate_unions(&self, unions: &[UnionSwift]) -> Result<String> {
        let mut content = String::from(CONTENT_PREFIX);
        content.push_str("\nimport Foundation\nimport SWAML\n\n// MARK: - Unions\n");

        for union in unions {
            let template = UnionTemplate { union };
            content.push_str(&template.render()?);
            content.push('\n');
        }

        Ok(content)
    }

    /// Generate BamlClient.swift content
    fn generate_client(&self, functions: &[FunctionSwift]) -> Result<String> {
        let template = ClientTemplate { functions };
        Ok(template.render()?)
    }

    /// Generate Globals.swift content
    fn generate_globals(&self, client_configs: &[ClientConfigSwift]) -> Result<String> {
        let template = GlobalsTemplate { client_configs };
        Ok(template.render()?)
    }

    /// Generate StreamTypes.swift content
    fn generate_stream_types(&self, classes: &[ClassSwift]) -> Result<String> {
        let template = StreamTypesTemplate { classes };
        Ok(template.render()?)
    }
}

// Askama templates

#[derive(Template)]
#[template(path = "types.swift.j2", escape = "none")]
struct TypesTemplate<'a> {
    enums: &'a [EnumSwift],
    classes: &'a [ClassSwift],
    type_aliases: &'a [TypeAliasSwift],
}

#[derive(Template)]
#[template(path = "union.swift.j2", escape = "none")]
struct UnionTemplate<'a> {
    union: &'a UnionSwift,
}

// Implement Deref for UnionTemplate to allow direct access to union fields in template
impl<'a> std::ops::Deref for UnionTemplate<'a> {
    type Target = UnionSwift;
    fn deref(&self) -> &Self::Target {
        self.union
    }
}

#[derive(Template)]
#[template(path = "client.swift.j2", escape = "none")]
struct ClientTemplate<'a> {
    functions: &'a [FunctionSwift],
}

#[derive(Template)]
#[template(path = "globals.swift.j2", escape = "none")]
struct GlobalsTemplate<'a> {
    client_configs: &'a [ClientConfigSwift],
}

#[derive(Template)]
#[template(path = "stream_types.swift.j2", escape = "none")]
struct StreamTypesTemplate<'a> {
    classes: &'a [ClassSwift],
}

/// Generate Swift code from BAML IR
///
/// This is a convenience function that creates a generator with default
/// configuration and generates all files.
pub fn generate_swift(ir: &BamlIR) -> Result<FileCollector> {
    let generator = SwiftGenerator::with_defaults();
    generator.generate(ir)
}

/// Generate Swift code with custom configuration
pub fn generate_swift_with_config(ir: &BamlIR, config: GeneratorConfig) -> Result<FileCollector> {
    let generator = SwiftGenerator::new(config);
    generator.generate(ir)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_generator_config_defaults() {
        let config = GeneratorConfig::default();
        assert_eq!(config.output_dir, "baml_client");
        assert_eq!(config.package_name, "BamlClient");
    }

    #[test]
    fn test_type_swift_serialization() {
        assert_eq!(TypeSwift::string().serialize(), "String");
        assert_eq!(TypeSwift::int().serialize(), "Int");
        assert_eq!(TypeSwift::float().serialize(), "Double");
        assert_eq!(TypeSwift::bool().serialize(), "Bool");
        assert_eq!(
            TypeSwift::optional(TypeSwift::string()).serialize(),
            "String?"
        );
        assert_eq!(TypeSwift::list(TypeSwift::int()).serialize(), "[Int]");
        assert_eq!(
            TypeSwift::map(TypeSwift::string(), TypeSwift::int()).serialize(),
            "[String: Int]"
        );
    }

    #[test]
    fn test_empty_ir_generates_files() {
        let ir = BamlIR::default();
        let generator = SwiftGenerator::with_defaults();
        let files = generator.generate(&ir).unwrap();

        assert!(files.get("baml_client/Types.swift").is_some());
        assert!(files.get("baml_client/BamlClient.swift").is_some());
        assert!(files.get("baml_client/Globals.swift").is_some());
    }

    #[test]
    fn test_generates_enum() {
        let ir = BamlIR {
            enums: vec![EnumDef {
                name: "Sentiment".to_string(),
                docstring: Some("User sentiment".to_string()),
                values: vec![
                    EnumValueDef {
                        name: "HAPPY".to_string(),
                        alias: None,
                        docstring: None,
                    },
                    EnumValueDef {
                        name: "SAD".to_string(),
                        alias: None,
                        docstring: None,
                    },
                ],
                dynamic: false,
            }],
            ..Default::default()
        };

        let generator = SwiftGenerator::with_defaults();
        let files = generator.generate(&ir).unwrap();
        let types = files.get("baml_client/Types.swift").unwrap();

        assert!(types.contains("public enum Sentiment"));
        assert!(types.contains("case happy"));
        assert!(types.contains("case sad"));
    }

    #[test]
    fn test_generates_class() {
        let ir = BamlIR {
            classes: vec![ClassDef {
                name: "User".to_string(),
                docstring: None,
                fields: vec![
                    FieldDef {
                        name: "user_name".to_string(),
                        field_type: FieldType::String,
                        docstring: None,
                    },
                    FieldDef {
                        name: "age".to_string(),
                        field_type: FieldType::Int,
                        docstring: None,
                    },
                ],
                has_dynamic_fields: false,
            }],
            ..Default::default()
        };

        let generator = SwiftGenerator::with_defaults();
        let files = generator.generate(&ir).unwrap();
        let types = files.get("baml_client/Types.swift").unwrap();

        assert!(types.contains("public struct User"));
        assert!(types.contains("public let userName: String"));
        assert!(types.contains("public let age: Int"));
        assert!(types.contains("CodingKeys")); // Should have coding keys for snake_case
    }

    #[test]
    fn test_generates_function() {
        let ir = BamlIR {
            functions: vec![FunctionDef {
                name: "classify_sentiment".to_string(),
                docstring: Some("Classify text sentiment".to_string()),
                params: vec![ParamDef {
                    name: "text".to_string(),
                    param_type: FieldType::String,
                    docstring: None,
                }],
                return_type: FieldType::Enum("Sentiment".to_string()),
                default_client: None,
                prompt: Some("Classify the sentiment: {{ text }}".to_string()),
            }],
            enums: vec![EnumDef {
                name: "Sentiment".to_string(),
                docstring: None,
                values: vec![],
                dynamic: false,
            }],
            ..Default::default()
        };

        let generator = SwiftGenerator::with_defaults();
        let files = generator.generate(&ir).unwrap();
        let client = files.get("baml_client/BamlClient.swift").unwrap();

        assert!(client.contains("func classifySentiment"));
        assert!(client.contains("text: String"));
        assert!(client.contains("-> Sentiment"));
    }
}
