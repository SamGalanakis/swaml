// Generated by BAML - do not edit
// swift-format-ignore-file

import Foundation
import SWAML

/// Options for BAML function calls (pure Swift runtime)
public struct BamlCallOptions: Sendable {
    /// TypeBuilder for dynamic enum values
    public let typeBuilder: TypeBuilder?

    /// Client name override
    public let clientName: String?

    public init(
        typeBuilder: TypeBuilder? = nil,
        clientName: String? = nil
    ) {
        self.typeBuilder = typeBuilder
        self.clientName = clientName
    }

    /// Create options with just a TypeBuilder
    public static func with(typeBuilder: TypeBuilder) -> BamlCallOptions {
        BamlCallOptions(typeBuilder: typeBuilder)
    }

    /// Create options with just a client name
    public static func with(clientName: String) -> BamlCallOptions {
        BamlCallOptions(clientName: clientName)
    }
}

#if BAML_FFI_ENABLED

/// Options for BAML FFI function calls
public struct BamlCallOptionsFFI: Sendable {
    /// TypeBuilder FFI handle for dynamic enum values
    public let typeBuilder: TypeBuilderFFI?

    /// Client name override
    public let clientName: String?

    /// Additional tags for tracing
    public let tags: [String: String]

    public init(
        typeBuilder: TypeBuilderFFI? = nil,
        clientName: String? = nil,
        tags: [String: String] = [:]
    ) {
        self.typeBuilder = typeBuilder
        self.clientName = clientName
        self.tags = tags
    }

    /// Create options with just a TypeBuilder FFI
    public static func with(typeBuilder: TypeBuilderFFI) -> BamlCallOptionsFFI {
        BamlCallOptionsFFI(typeBuilder: typeBuilder)
    }

    /// Create options with just a client name
    public static func with(clientName: String) -> BamlCallOptionsFFI {
        BamlCallOptionsFFI(clientName: clientName)
    }
}

#endif // BAML_FFI_ENABLED

#if BAML_FFI_ENABLED

// MARK: - FFI-Based Client (uses BAML Rust runtime)

/// Async BAML client using the FFI runtime (BAML Rust backend)
public actor BamlAsyncClientFFI {
    private let runtime: BamlRuntimeFFI

    public init(runtime: BamlRuntimeFFI) {
        self.runtime = runtime
    }
{% for func in functions %}

{% if func.docstring.is_some() %}
    /// {{ func.docstring.as_ref().unwrap() }}
{% endif %}
    public func {{ func.name }}(
{% for param in func.params %}
        {{ param.name }}: {{ param.type_string() }}{% if param.has_default() %} = {{ param.default_value.as_ref().unwrap() }}{% endif %},
{% endfor %}
        options: BamlCallOptionsFFI? = nil
    ) async throws -> {{ func.return_type_string() }} {
        // Build protobuf arguments
        var kwargs: [HostMapEntry] = []
{% for param in func.params %}
        kwargs.append(HostMapEntry(stringKey: "{{ param.baml_name }}", value: try HostValue.from({{ param.name }})))
{% endfor %}

        var arguments = HostFunctionArguments(kwargs: kwargs)

        // Add TypeBuilder handle if present
        if let tb = options?.typeBuilder {
            arguments.typeBuilder = tb.toBamlObjectHandle()
        }

        // Add tags if present
        if let tags = options?.tags, !tags.isEmpty {
            arguments.tags = tags.map { HostMapEntry(stringKey: $0.key, value: .string($0.value)) }
        }

        // Call FFI runtime with protobuf encoding
        let resultData = try await runtime.callFunctionProto("{{ func.baml_name }}", arguments: arguments)

        // Decode result
        return try JSONDecoder().decode({{ func.return_type_string() }}.self, from: resultData)
    }

    /// Stream {{ func.name }} with partial results
    public func {{ func.name }}Stream(
{% for param in func.params %}
        {{ param.name }}: {{ param.type_string() }}{% if param.has_default() %} = {{ param.default_value.as_ref().unwrap() }}{% endif %},
{% endfor %}
        options: BamlCallOptionsFFI? = nil
    ) -> AsyncThrowingStream<Partial{{ func.return_type_string() }}, Error> {
        AsyncThrowingStream { continuation in
            Task {
                do {
                    // Build protobuf arguments
                    var kwargs: [HostMapEntry] = []
{% for param in func.params %}
                    kwargs.append(HostMapEntry(stringKey: "{{ param.baml_name }}", value: try HostValue.from({{ param.name }})))
{% endfor %}

                    var arguments = HostFunctionArguments(kwargs: kwargs)

                    // Add TypeBuilder handle if present
                    if let tb = options?.typeBuilder {
                        arguments.typeBuilder = tb.toBamlObjectHandle()
                    }

                    // Encode as protobuf
                    let argsData = try arguments.serializedData()

                    for try await chunk in runtime.callFunctionStream("{{ func.baml_name }}", args: argsData) {
                        if let partial = try? JSONDecoder().decode(Partial{{ func.return_type_string() }}.self, from: chunk) {
                            continuation.yield(partial)
                        }
                    }
                    continuation.finish()
                } catch {
                    continuation.finish(throwing: error)
                }
            }
        }
    }
{% endfor %}
}

#endif // BAML_FFI_ENABLED

// MARK: - Pure Swift Client (uses SWAML runtime)

/// Async BAML client using the pure Swift runtime
public actor BamlAsyncClient {
    private let runtime: BamlRuntime

    public init(runtime: BamlRuntime) {
        self.runtime = runtime
    }
{% for func in functions %}

{% if func.docstring.is_some() %}
    /// {{ func.docstring.as_ref().unwrap() }}
{% endif %}
    public func {{ func.name }}(
{% for param in func.params %}
        {{ param.name }}: {{ param.type_string() }}{% if param.has_default() %} = {{ param.default_value.as_ref().unwrap() }}{% endif %},
{% endfor %}
        options: BamlCallOptions? = nil
    ) async throws -> {{ func.return_type_string() }} {
        let args: [String: BamlValue] = [
{% for param in func.params %}
            "{{ param.baml_name }}": try BamlValue.from({{ param.name }}){% if !loop.last %},{% endif %}

{% endfor %}
        ]
{% if func.prompt.is_some() %}

        let prompt = {{ func.prompt_literal().unwrap() }}
{% endif %}

        var ctx = RuntimeContext.default
        if let clientName = options?.clientName {
            ctx = RuntimeContext(clientName: clientName)
        }

        return try await runtime.callFunction(
            "{{ func.baml_name }}",
            args: args,
{% if func.prompt.is_some() %}
            prompt: prompt,
{% endif %}
            outputType: {{ func.return_type_string() }}.self,
            typeBuilder: options?.typeBuilder,
            ctx: ctx
        )
    }
{% endfor %}
}

/// Sync wrapper for BamlAsyncClient (for non-async contexts)
public final class BamlSyncClient: @unchecked Sendable {
    private let asyncClient: BamlAsyncClient

    public init(runtime: BamlRuntime) {
        self.asyncClient = BamlAsyncClient(runtime: runtime)
    }
{% for func in functions %}

{% if func.docstring.is_some() %}
    /// {{ func.docstring.as_ref().unwrap() }}
{% endif %}
    public func {{ func.name }}(
{% for param in func.params %}
        {{ param.name }}: {{ param.type_string() }}{% if param.has_default() %} = {{ param.default_value.as_ref().unwrap() }}{% endif %},
{% endfor %}
        options: BamlCallOptions? = nil
    ) throws -> {{ func.return_type_string() }} {
        let semaphore = DispatchSemaphore(value: 0)
        var result: Result<{{ func.return_type_string() }}, Error>!

        Task {
            do {
                let value = try await asyncClient.{{ func.name }}(
{% for param in func.params %}
                    {{ param.name }}: {{ param.name }},
{% endfor %}
                    options: options
                )
                result = .success(value)
            } catch {
                result = .failure(error)
            }
            semaphore.signal()
        }

        semaphore.wait()
        return try result.get()
    }
{% endfor %}
}

#if BAML_FFI_ENABLED

/// Sync wrapper for BamlAsyncClientFFI (for non-async contexts)
public final class BamlSyncClientFFI: @unchecked Sendable {
    private let asyncClient: BamlAsyncClientFFI

    public init(runtime: BamlRuntimeFFI) {
        self.asyncClient = BamlAsyncClientFFI(runtime: runtime)
    }
{% for func in functions %}

{% if func.docstring.is_some() %}
    /// {{ func.docstring.as_ref().unwrap() }}
{% endif %}
    public func {{ func.name }}(
{% for param in func.params %}
        {{ param.name }}: {{ param.type_string() }}{% if param.has_default() %} = {{ param.default_value.as_ref().unwrap() }}{% endif %},
{% endfor %}
        options: BamlCallOptionsFFI? = nil
    ) throws -> {{ func.return_type_string() }} {
        let semaphore = DispatchSemaphore(value: 0)
        var result: Result<{{ func.return_type_string() }}, Error>!

        Task {
            do {
                let value = try await asyncClient.{{ func.name }}(
{% for param in func.params %}
                    {{ param.name }}: {{ param.name }},
{% endfor %}
                    options: options
                )
                result = .success(value)
            } catch {
                result = .failure(error)
            }
            semaphore.signal()
        }

        semaphore.wait()
        return try result.get()
    }
{% endfor %}
}

#endif // BAML_FFI_ENABLED

/// Protocol for types that can be converted to BamlValue
public protocol BamlValueConvertible {
    func toBamlValue() throws -> BamlValue
}

extension BamlValue {
    /// Create a BamlValue from any supported type
    public static func from<T: Encodable>(_ value: T) throws -> BamlValue {
        let data = try JSONEncoder().encode(value)
        return try JSONDecoder().decode(BamlValue.self, from: data)
    }
}
