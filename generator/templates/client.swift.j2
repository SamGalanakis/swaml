// Generated by BAML - do not edit
// swift-format-ignore-file

import Foundation
import SWAML

/// Async BAML client with all generated functions
public actor BamlAsyncClient {
    private let runtime: BamlRuntime

    public init(runtime: BamlRuntime) {
        self.runtime = runtime
    }
{% for func in functions %}

{% if func.doc.is_some() %}
    /// {{ func.doc.as_ref().unwrap() }}
{% endif %}
    public func {{ func.name|camel_case }}(
{% for param in func.params %}
        {{ param.name|camel_case }}: {{ param.param_type|swift_type }}{% if param.default_value.is_some() %} = {{ param.default_value.as_ref().unwrap() }}{% endif %}{% if !loop.last %},{% endif %}

{% endfor %}
    ) async throws -> {{ func.return_type|swift_type }} {
        let args: [String: BamlValue] = [
{% for param in func.params %}
            "{{ param.name }}": {{ param|to_baml_value }}{% if !loop.last %},{% endif %}

{% endfor %}
        ]

        // Build prompt from template
        let prompt = """
        {{ func.prompt_template }}
        """

        return try await runtime.callFunction(
            "{{ func.name }}",
            args: args,
            prompt: prompt,
            outputType: {{ func.return_type|swift_type }}.self,
            ctx: RuntimeContext()
        )
    }
{% endfor %}
}

/// Sync wrapper for BamlAsyncClient (for non-async contexts)
public final class BamlSyncClient: @unchecked Sendable {
    private let asyncClient: BamlAsyncClient

    public init(runtime: BamlRuntime) {
        self.asyncClient = BamlAsyncClient(runtime: runtime)
    }
{% for func in functions %}

    public func {{ func.name|camel_case }}(
{% for param in func.params %}
        {{ param.name|camel_case }}: {{ param.param_type|swift_type }}{% if param.default_value.is_some() %} = {{ param.default_value.as_ref().unwrap() }}{% endif %}{% if !loop.last %},{% endif %}

{% endfor %}
    ) throws -> {{ func.return_type|swift_type }} {
        let semaphore = DispatchSemaphore(value: 0)
        var result: Result<{{ func.return_type|swift_type }}, Error>!

        Task {
            do {
                let value = try await asyncClient.{{ func.name|camel_case }}(
{% for param in func.params %}
                    {{ param.name|camel_case }}: {{ param.name|camel_case }}{% if !loop.last %},{% endif %}

{% endfor %}
                )
                result = .success(value)
            } catch {
                result = .failure(error)
            }
            semaphore.signal()
        }

        semaphore.wait()
        return try result.get()
    }
{% endfor %}
}
