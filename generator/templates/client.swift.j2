// Generated by BAML - do not edit
// swift-format-ignore-file

import Foundation
import SWAML

/// Options for BAML function calls
public struct BamlCallOptions: Sendable {
    /// TypeBuilder for dynamic enum values
    public let typeBuilder: TypeBuilder?

    /// Client name override
    public let clientName: String?

    public init(
        typeBuilder: TypeBuilder? = nil,
        clientName: String? = nil
    ) {
        self.typeBuilder = typeBuilder
        self.clientName = clientName
    }

    /// Create options with just a TypeBuilder
    public static func with(typeBuilder: TypeBuilder) -> BamlCallOptions {
        BamlCallOptions(typeBuilder: typeBuilder)
    }

    /// Create options with just a client name
    public static func with(clientName: String) -> BamlCallOptions {
        BamlCallOptions(clientName: clientName)
    }
}

/// Async BAML client with all generated functions
public actor BamlAsyncClient {
    private let runtime: BamlRuntime

    public init(runtime: BamlRuntime) {
        self.runtime = runtime
    }
{% for func in functions %}

{% if func.docstring.is_some() %}
    /// {{ func.docstring.as_ref().unwrap() }}
{% endif %}
    public func {{ func.name }}(
{% for param in func.params %}
        {{ param.name }}: {{ param.type_string() }}{% if param.has_default() %} = {{ param.default_value.as_ref().unwrap() }}{% endif %},
{% endfor %}
        options: BamlCallOptions? = nil
    ) async throws -> {{ func.return_type_string() }} {
        let args: [String: BamlValue] = [
{% for param in func.params %}
            "{{ param.baml_name }}": try BamlValue.from({{ param.name }}){% if !loop.last %},{% endif %}

{% endfor %}
        ]
{% if func.prompt.is_some() %}

        let prompt = {{ func.prompt_literal().unwrap() }}
{% endif %}

        var ctx = RuntimeContext.default
        if let clientName = options?.clientName {
            ctx = RuntimeContext(clientName: clientName)
        }

        return try await runtime.callFunction(
            "{{ func.baml_name }}",
            args: args,
{% if func.prompt.is_some() %}
            prompt: prompt,
{% endif %}
            outputType: {{ func.return_type_string() }}.self,
            typeBuilder: options?.typeBuilder,
            ctx: ctx
        )
    }
{% endfor %}
}

/// Sync wrapper for BamlAsyncClient (for non-async contexts)
public final class BamlSyncClient: @unchecked Sendable {
    private let asyncClient: BamlAsyncClient

    public init(runtime: BamlRuntime) {
        self.asyncClient = BamlAsyncClient(runtime: runtime)
    }
{% for func in functions %}

{% if func.docstring.is_some() %}
    /// {{ func.docstring.as_ref().unwrap() }}
{% endif %}
    public func {{ func.name }}(
{% for param in func.params %}
        {{ param.name }}: {{ param.type_string() }}{% if param.has_default() %} = {{ param.default_value.as_ref().unwrap() }}{% endif %},
{% endfor %}
        options: BamlCallOptions? = nil
    ) throws -> {{ func.return_type_string() }} {
        let semaphore = DispatchSemaphore(value: 0)
        var result: Result<{{ func.return_type_string() }}, Error>!

        Task {
            do {
                let value = try await asyncClient.{{ func.name }}(
{% for param in func.params %}
                    {{ param.name }}: {{ param.name }},
{% endfor %}
                    options: options
                )
                result = .success(value)
            } catch {
                result = .failure(error)
            }
            semaphore.signal()
        }

        semaphore.wait()
        return try result.get()
    }
{% endfor %}
}

/// Protocol for types that can be converted to BamlValue
public protocol BamlValueConvertible {
    func toBamlValue() throws -> BamlValue
}

extension BamlValue {
    /// Create a BamlValue from any supported type
    public static func from<T: Encodable>(_ value: T) throws -> BamlValue {
        let data = try JSONEncoder().encode(value)
        return try JSONDecoder().decode(BamlValue.self, from: data)
    }
}
