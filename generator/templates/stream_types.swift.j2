// Generated by BAML - do not edit
// swift-format-ignore-file

import Foundation
import SWAML

// MARK: - Streaming (Partial) Types
//
// These types are used during streaming to represent partial results.
// All fields are optional to allow for incremental updates.
{% for class in classes %}

{% if class.docstring.is_some() %}
/// {{ class.docstring.as_ref().unwrap() }}
{% endif %}
public struct {{ class.name }}: Codable, Sendable, Equatable {
{% for field in class.fields %}
{% if field.docstring.is_some() %}
    /// {{ field.docstring.as_ref().unwrap() }}
{% endif %}
    public var {{ field.name }}: {{ field.type_string() }}
{% endfor %}
{% if class.needs_coding_keys() %}

    private enum CodingKeys: String, CodingKey {
{% for field in class.fields %}
{% if field.baml_name != field.name %}
        case {{ field.name }} = "{{ field.baml_name }}"
{% else %}
        case {{ field.name }}
{% endif %}
{% endfor %}
    }
{% endif %}

    public init(
{% for field in class.fields %}
        {{ field.name }}: {{ field.type_string() }} = nil{% if !loop.last %},{% endif %}

{% endfor %}
    ) {
{% for field in class.fields %}
        self.{{ field.name }} = {{ field.name }}
{% endfor %}
    }

    /// Merge another partial into this one, preferring non-nil values from the other
    public mutating func merge(_ other: {{ class.name }}) {
{% for field in class.fields %}
        if let value = other.{{ field.name }} {
            self.{{ field.name }} = value
        }
{% endfor %}
    }
}
{% endfor %}

// MARK: - Stream State

/// Represents the state of a streaming response
public struct StreamState<T: Codable & Sendable>: Codable, Sendable {
    /// The current partial value
    public var partial: T?

    /// Whether the stream has completed
    public var isComplete: Bool

    /// The final value (only set when isComplete is true)
    public var final: T?

    public init(partial: T? = nil, isComplete: Bool = false, final: T? = nil) {
        self.partial = partial
        self.isComplete = isComplete
        self.final = final
    }
}

/// Represents a checked value with validation results
public struct Checked<T: Codable & Sendable>: Codable, Sendable, Equatable where T: Equatable {
    /// The underlying value
    public let value: T

    /// The validation check results
    public let checks: [String: CheckResult]

    public init(value: T, checks: [String: CheckResult] = [:]) {
        self.value = value
        self.checks = checks
    }
}

/// Result of a validation check
public struct CheckResult: Codable, Sendable, Equatable {
    /// Whether the check passed
    public let passed: Bool

    /// Optional message describing the result
    public let message: String?

    public init(passed: Bool, message: String? = nil) {
        self.passed = passed
        self.message = message
    }
}
